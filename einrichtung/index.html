<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

    <title>WebGL Tutorial - Einrichtung</title>

    <link rel="stylesheet" href="/webgl_tutorial/semantic.min.css">
    <link rel="stylesheet" href="/webgl_tutorial/style.css">
  </head>

    <body>
<div class="ui vertical inverted sidebar menu">
    <a class="item" href="/webgl_tutorial/">Startseite</a>
    
    
    <a class="active item" href="/webgl_tutorial/einrichtung/">Einrichtung</a>
    
    
</div>

<div class="pusher">
    <div class="ui vertical post segment">
        <div class="ui container">
            <div class="ui secondary pointing menu">
                <a class="toc item"><i class="sidebar icon"></i></a>
                <a class="header item" href="/webgl_tutorial/">WebGL Tutorial</a>
                <div class="right menu">
                    
                    
                    <a class="active item" href="/webgl_tutorial/einrichtung/">Einrichtung</a>
                    
                    
                </div>
            </div>
        </div>

        <div class="ui text container">
            <h1 class="ui header">Einrichtung</h1>
            <div class="ui info message"><div class="header">Hinweis</div>Falls Sie es eilig haben, können Sie auch eine bereits eingerichtete Ordnerstruktur von <a href="https://github.com/mickiboy/webgl_template" target="_blank" rel="external">GitHub</a> klonen. Zusätzlich gibt es die Möglichkeit, den Browser automatisch neu laden zu lassen, sobald Sie Änderungen am Quellcode vornehmen.</div>

<p>Um mit WebGL durchzustarten, sollten wir nun schrittweise versuchen, ein<br>einfaches Dreieck zu zeichnen. Dazu brauchen wir eine HTML-Datei, deren Körper<br>lediglich aus einem Canvas bestehen kann. Zusätzlich müssen sowohl ein Vertex-<br>als auch ein Fragment-Shader eingebettet werden. Was diese Shader machen, wird<br>am Schluss erklärt.</p>
<h2 id="HTML-und-CSS"><a href="#HTML-und-CSS" class="headerlink" title="HTML und CSS"></a>HTML und CSS</h2><p>Da dies ein Tutorial für WebGL ist, wird der Fokus auf JavaScript gelegt,<br>deshalb hier beispielhaft ein vollständiges HTML-Dokument, inklusive<br>Anpassungen per CSS:</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt;

    &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;

    &lt;title&gt;WebGL Template&lt;/title&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;canvas id=&quot;webgl-canvas&quot;&gt;&lt;/canvas&gt;

    &lt;script id=&quot;vertex-shader&quot; type=&quot;x-shader/x-vertex&quot;&gt;
      attribute vec2 a_position;

      void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
      }
    &lt;/script&gt;

    &lt;script id=&quot;fragment-shader&quot; type=&quot;x-shader/x-fragment&quot;&gt;
      precision mediump float;

      void main() {
        gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
      }
    &lt;/script&gt;

    &lt;script type=&quot;text/javascript&quot; src=&quot;http://cdnjs.cloudflare.com/ajax/libs/mathjs/3.12.0/math.min.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;helpers.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;script.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="css">body {
  margin: 0;
}

#webgl-canvas {
  width: 100vw;
  height: 100vh;
  display: block;
}
</code></pre>
<p>In der HTML-Datei befinden sich auch Verweise auf mehrere JavaScripts. Das<br>erste ist Math.js, eine nützliche Bibliothek mit vielen nützlichen<br>mathematischen Funktionen. Das zweite Skript enthält zwei Funktionen, die<br>dafür sorgen, dass die oben angegebenen Shader kompiliert werden. Dieses<br>Skript sieht so aus:</p>
<pre><code class="js">function priv_compileShader(gl, type, source) {
    var shader = gl.createShader(type);

    gl.shaderSource(shader, source);
    gl.compileShader(shader);

    var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
    if (success) return shader;

    console.log(gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
}

/**
 * Creates a shader program from the given source code of the vertex and
 * fragment shader.
 *
 * @param gl WebGL context
 * @param vertexShader ID of the vertex shader
 * @param fragmentShader ID of the fragment shader
 * @return Program ID for WebGL
 */
function createShaderProgram(gl, vertexShader, fragmentShader) {
    var compiledVertexShader = priv_compileShader(gl, gl.VERTEX_SHADER, document.getElementById(vertexShader).text);
    var compiledFragmentShader = priv_compileShader(gl, gl.FRAGMENT_SHADER, document.getElementById(fragmentShader).text);
    var program = gl.createProgram();

    gl.attachShader(program, compiledVertexShader);
    gl.attachShader(program, compiledFragmentShader);
    gl.linkProgram(program);

    var success = gl.getProgramParameter(program, gl.LINK_STATUS);
    if (success) return program;

    console.log(gl.getProgramInfoLog(program));
    gl.deleteProgram(program);
}
</code></pre>
<p>Zu guter Letzt das wichtigste Skript, dort werden die WebGL-Funktionen<br>aufgerufen.</p>
<h2 id="Initialisierung"><a href="#Initialisierung" class="headerlink" title="Initialisierung"></a>Initialisierung</h2><p>Um WebGL zu initialisieren, müssen wir ein Kontext erstellen. Dazu benötigen<br>wir das Canvas-Element:</p>
<pre><code class="js">var canvas = document.getElementById(&quot;webgl-canvas&quot;);
</code></pre>
<p>Anschließend kann mit</p>
<pre><code class="js">var gl = canvas.getContext(&quot;webgl&quot;);
</code></pre>
<p>ein WebGL-Kontext erstellt werden. Alle WebGL-Funktionen werden nun über<br>die <code>gl</code>-Variable aufgerufen.</p>
<h2 id="Shader-kompilieren-und-linken"><a href="#Shader-kompilieren-und-linken" class="headerlink" title="Shader kompilieren und linken"></a>Shader kompilieren und linken</h2><p>Da wir bereits eine Funktion haben, die sich darum kümmert, brauchen wir<br>lediglich</p>
<pre><code class="js">var program = createShaderProgram(gl, &quot;vertex-shader&quot;, &quot;fragment-shader&quot;);
</code></pre>
<p>zu schreiben. Für die Koordinaten benötigen wir noch eine Anbindung an den<br>Shader. Diese wird erstellt mit</p>
<pre><code class="js">var positionAttributeLocation = gl.getAttribLocation(program, &quot;a_position&quot;);
</code></pre>
<h2 id="Koordinaten-ubergeben"><a href="#Koordinaten-ubergeben" class="headerlink" title="Koordinaten übergeben"></a>Koordinaten übergeben</h2><p>Jetzt, da wir WebGL soweit eingerichtet haben, können wir anfangen, das Dreieck<br>zu definieren. Dafür brauchen wir zuerst einen Puffer, der diese Koordinaten<br>enthält:</p>
<pre><code class="js">var positionBuffer = gl.createBuffer();
</code></pre>
<p>Dieser Puffer muss nun aktiviert werden, um diesen mit Daten zu füllen. Um es<br>in WebGL-Sprache zu übersetzen: Der Puffer muss angebunden werden:</p>
<pre><code class="js">gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
</code></pre>
<p>Der erste Parameter gibt an, um welche Art von Puffer es sich handelt, der<br>zweite Parameter erwartet den Puffer selbst.</p>
<p>Jetzt müssen wir die Koordinaten übergeben. Dazu muss ein eindimensionales<br>Array erstellt und an WebGL übergeben werden:</p>
<pre><code class="js">var vertices = [
    /** x, y */
    0.0, 0.0,  /** Vertex bottom-left */
    0.0, 0.5,  /** Vertex top-left */
    0.5, 0.0,  /** Vertex bottom-right */
];

gl.bindBuffer(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
</code></pre>
<p>Der erste Parameter gibt wiederum an, um welche Art von Puffer es sich handelt,<br>der zweite Parameter ein Float-Array (hier mit <code>Float32Array</code> erstellt, da<br>WebGL zwingend ein Float-Array voraussetzt). Der letzte Parameter gibt an,<br>wie oft sich diese Daten ändern werden. Da sich die Koordinaten nie ändern<br>werden, wird hier ein <code>gl.STATIC_DRAW</code> übergeben. Damit wird WebGL mitgeteilt,<br>wo die Daten im Arbeitsspeicher der GPU abgelegt werden, um den Workflow zu<br>optimieren.</p>
<h2 id="Vorbereitungen-zum-Rendern"><a href="#Vorbereitungen-zum-Rendern" class="headerlink" title="Vorbereitungen zum Rendern"></a>Vorbereitungen zum Rendern</h2><p>Die nachfolgenden Schritte werden stets pro Frame vorgenommen.</p>
<h3 id="Kontext-an-Canvas-Grose-anpassen"><a href="#Kontext-an-Canvas-Grose-anpassen" class="headerlink" title="Kontext an Canvas-Größe anpassen"></a>Kontext an Canvas-Größe anpassen</h3><p>Damit WebGL jeweils mit dem Browser zusammen skaliert, muss der Viewport<br>gesetzt werden:</p>
<pre><code class="js">gl.canvas.width = gl.canvas.clientWidth;
gl.canvas.height = gl.canvas.clientHeight;

gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
</code></pre>
<h3 id="Hintergrundfarbe-setzen"><a href="#Hintergrundfarbe-setzen" class="headerlink" title="Hintergrundfarbe setzen"></a>Hintergrundfarbe setzen</h3><p>Dazu wird zuerst die Farbe gesetzt und anschließend der Bildspeicher mit dieser<br>Farbe gefüllt:</p>
<pre><code class="js">gl.clearColor(0.2, 0.2, 0.2, 1.0);
gl.clear(gl.COLOR_BUFFER_BIT);
</code></pre>
<h3 id="Shader-aktivieren"><a href="#Shader-aktivieren" class="headerlink" title="Shader aktivieren"></a>Shader aktivieren</h3><p>Jetzt muss das zuvor erstellte Shader-Programm aktiviert werden und das<br>Positionsattribut angebunden werden:</p>
<pre><code class="js">gl.useProgram(program);
gl.enableVertexAttribArray(positionAttributeLocation);
</code></pre>
<h3 id="Koordinaten-Puffer-aktivieren"><a href="#Koordinaten-Puffer-aktivieren" class="headerlink" title="Koordinaten-Puffer aktivieren"></a>Koordinaten-Puffer aktivieren</h3><p>Der zuvor erstellte Puffer für die Koordniaten muss jetzt aktiviert werden:</p>
<pre><code class="js">gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
</code></pre>
<p>Der erste Parameter der Funktion enthält die Anbindung an das Attribut im<br>Vertex-Shader, der zweite Parameter die Anzahl der Dimensionen (hier 2),<br>der dritte Parameter den Variablentyp. Die anderen Parameter ignorieren wir<br>vorerst.</p>
<h3 id="Zeichenbefehl-ubergeben"><a href="#Zeichenbefehl-ubergeben" class="headerlink" title="Zeichenbefehl übergeben"></a>Zeichenbefehl übergeben</h3><p>Jetzt kommt der eigentlich wichtigste Moment, das Zeichnen des Dreiecks:</p>
<pre><code class="js">gl.drawArrays(gl.TRIANGLES, 0, 3);
</code></pre>
<p>Der erste Parameter gibt an, auf welche Art er die zuvor angebundenen<br>Koordinaten zeichen soll, der zweite Parameter den Offset im Array und der<br>letzte Parameter die Anzahl der Koordinaten.</p>
<p>Das waren die Schritte, die zum Zeichnen eines Dreiecks nötig waren.</p>

        </div>
    </div>
</div>

        <script src="https://code.jquery.com/jquery-3.1.1.min.js"></script>
        <script src="/webgl_tutorial/semantic.min.js"></script>
        <script src="/webgl_tutorial/helpers.js"></script>
        <script src="/webgl_tutorial/script.js"></script>
    </body>
</html>
