<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

    <title>WebGL Tutorial - 1. Einrichtung</title>

    <link rel="stylesheet" href="/webgl_tutorial/semantic.min.css">
    <link rel="stylesheet" href="/webgl_tutorial/style.css">
  </head>

    <body>
<div class="ui vertical inverted sidebar menu">
    <a class="item" href="/webgl_tutorial/">Startseite</a>
    
    
    <a class="active item" href="/webgl_tutorial/1-einrichtung/">1. Einrichtung</a>
    
    
    
    <a class="item" href="/webgl_tutorial/2-shader/">2. Shader</a>
    
    
    
    <a class="item" href="/webgl_tutorial/4-szenegraph/">4. Szenegraph</a>
    
    
    
    <a class="item" href="/webgl_tutorial/3-transformationen/">3. Transformationen</a>
    
    
</div>

<div class="pusher">
    <div class="ui vertical post segment">
        <div class="ui container">
            <div class="ui secondary pointing menu">
                <a class="toc item"><i class="sidebar icon"></i></a>
                <a class="header item" href="/webgl_tutorial/">WebGL Tutorial</a>
                <div class="right menu">
                    
                    
                    <a class="active item" href="/webgl_tutorial/1-einrichtung/">1. Einrichtung</a>
                    
                    
                    
                    <a class="item" href="/webgl_tutorial/2-shader/">2. Shader</a>
                    
                    
                    
                    <a class="item" href="/webgl_tutorial/4-szenegraph/">4. Szenegraph</a>
                    
                    
                    
                    <a class="item" href="/webgl_tutorial/3-transformationen/">3. Transformationen</a>
                    
                    
                </div>
            </div>
        </div>

        <div class="ui text container">
            <h1 class="ui header">1. Einrichtung</h1>
            <div class="ui info message"><div class="header">Hinweis</div>Falls Sie mehr Komfort benötigen, können Sie auch eine bereits eingerichtete Ordnerstruktur von <a href="https://github.com/mickiboy/webgl_template" target="_blank" rel="external">GitHub</a> klonen. Zusätzlich gibt es die Möglichkeit, den Browser automatisch neu laden zu lassen, sobald Sie Änderungen am Quellcode vornehmen.</div>

<p>Um mit WebGL durchzustarten, sollten wir nun schrittweise versuchen, ein einfaches, weißes Dreieck zu zeichnen. Dazu brauchen wir eine HTML-Datei, deren Körper lediglich aus einem Canvas bestehen kann. Zusätzlich müssen sowohl ein Vertex- als auch ein Fragment-Shader eingebettet werden. Was diese Shader machen, wird im nächsten Tutorial erklärt.</p>
<h2 id="HTML-und-CSS"><a href="#HTML-und-CSS" class="headerlink" title="HTML und CSS"></a>HTML und CSS</h2><p>Da dies ein Tutorial für WebGL ist, wird der Fokus auf JavaScript gelegt, deshalb hier beispielhaft ein vollständiges HTML-Dokument, inklusive Anpassungen per CSS:</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt;

    &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;

    &lt;title&gt;WebGL Template&lt;/title&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;canvas id=&quot;webgl-canvas&quot;&gt;&lt;/canvas&gt;

    &lt;script id=&quot;vertex-shader&quot; type=&quot;x-shader/x-vertex&quot;&gt;
      attribute vec2 a_position;

      void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
      }
    &lt;/script&gt;

    &lt;script id=&quot;fragment-shader&quot; type=&quot;x-shader/x-fragment&quot;&gt;
      precision mediump float;

      void main() {
        gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
      }
    &lt;/script&gt;

    &lt;script type=&quot;text/javascript&quot; src=&quot;http://cdnjs.cloudflare.com/ajax/libs/mathjs/3.12.0/math.min.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;helpers.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;script.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="css">body {
  margin: 0;
}

#webgl-canvas {
  width: 100vw;
  height: 100vh;
  display: block;
}
</code></pre>
<p>Um die Dateien lokal zu öffnen, müssen die Shader zwingend im HTML-Dokument eingebettet sein. Falls man die Shader in separate Dateien auslagern will, muss man einen lokalen Webserver einrichten, welches den Rahmen dieses Tutorials aber sprengen würde.</p>
<p>In der HTML-Datei befinden sich auch Verweise auf mehrere JavaScripts. Das erste ist Math.js, eine Bibliothek mit vielen nützlichen mathematischen Funktionen. Das zweite Skript enthält zwei Funktionen, die dafür sorgen, dass die oben angegebenen Shader kompiliert und gelinkt werden. Dieses Skript sieht so aus:</p>
<pre><code class="js">function priv_compileShader(gl, type, source) {
    var shader = gl.createShader(type);

    gl.shaderSource(shader, source);
    gl.compileShader(shader);

    var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
    if (success) return shader;

    console.log(gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
}

/**
 * Creates a shader program from the given source code of the vertex and
 * fragment shader.
 *
 * @param gl WebGL context
 * @param vertexShader ID of the vertex shader
 * @param fragmentShader ID of the fragment shader
 * @return Program ID for WebGL
 */
function createShaderProgram(gl, vertexShader, fragmentShader) {
    var compiledVertexShader = priv_compileShader(gl, gl.VERTEX_SHADER, document.getElementById(vertexShader).text);
    var compiledFragmentShader = priv_compileShader(gl, gl.FRAGMENT_SHADER, document.getElementById(fragmentShader).text);
    var program = gl.createProgram();

    gl.attachShader(program, compiledVertexShader);
    gl.attachShader(program, compiledFragmentShader);
    gl.linkProgram(program);

    var success = gl.getProgramParameter(program, gl.LINK_STATUS);
    if (success) return program;

    console.log(gl.getProgramInfoLog(program));
    gl.deleteProgram(program);
}
</code></pre>
<p>Zu guter Letzt das wichtigste Skript, dort werden die WebGL-Funktionen aufgerufen.</p>
<h2 id="Initialisierung"><a href="#Initialisierung" class="headerlink" title="Initialisierung"></a>Initialisierung</h2><p>Um WebGL zu initialisieren, müssen wir ein Kontext erstellen. Dazu benötigen wir das Canvas-Element:</p>
<pre><code class="js">var canvas = document.getElementById(&quot;webgl-canvas&quot;);
</code></pre>
<p>Anschließend kann mit</p>
<pre><code class="js">var gl = canvas.getContext(&quot;webgl&quot;);
</code></pre>
<p>ein WebGL-Kontext erstellt werden. Alle WebGL-Funktionen werden nun über die <code>gl</code>-Variable aufgerufen.</p>
<h2 id="Koordinaten-ubergeben"><a href="#Koordinaten-ubergeben" class="headerlink" title="Koordinaten übergeben"></a>Koordinaten übergeben</h2><p>Nachdem der Kontext erstellt wurde, können wir anfangen, das Dreieck zu definieren. Dafür brauchen wir zuerst einen Puffer, der diese Koordinaten enthält:</p>
<pre><code class="js">var positionBuffer = gl.createBuffer();
</code></pre>
<p>Dieser Puffer muss nun an WebGL angebunden (aktiviert) werden, um diesen mit Daten zu füllen:</p>
<pre><code class="js">gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
</code></pre>
<p>Der erste Parameter gibt an, um welche Art von Puffer es sich handelt, der zweite Parameter erwartet den Puffer selbst.</p>
<p>Jetzt müssen wir die Koordinaten übergeben. Dazu muss ein eindimensionales Array erstellt und an WebGL übergeben werden:</p>
<pre><code class="js">var vertices = [
    /** x, y */
    0.0, 0.0,  /** Vertex bottom-left */
    0.0, 0.5,  /** Vertex top-left */
    0.5, 0.0,  /** Vertex bottom-right */
];

gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
</code></pre>
<p>Der erste Parameter gibt wiederum an, um welche Art von Puffer es sich handelt, der zweite Parameter ein Float-Array (hier mit <code>Float32Array</code> erstellt, da WebGL zwingend ein Float-Array voraussetzt). Der letzte Parameter gibt an, wie oft sich diese Daten ändern werden. Da sich die Koordinaten nie ändern werden, wird hier ein <code>gl.STATIC_DRAW</code> übergeben. Damit wird WebGL mitgeteilt, wo die Daten im Arbeitsspeicher der GPU abgelegt werden, damit diese das Rendering optimieren kann.</p>
<p>Da WebGL mindestens einen Vertex- und einen Fragment-Shader erfordert, werden wir nun diese kompilieren und linken.</p>
<h2 id="Shader-kompilieren-und-linken"><a href="#Shader-kompilieren-und-linken" class="headerlink" title="Shader kompilieren und linken"></a>Shader kompilieren und linken</h2><p>Da wir bereits eine Funktion haben, die sich darum kümmert, brauchen wir lediglich</p>
<pre><code class="js">var program = createShaderProgram(gl, &quot;vertex-shader&quot;, &quot;fragment-shader&quot;);
</code></pre>
<p>zu schreiben. Die letzten beiden Parameter stehen jeweils für die IDs, die wir im HTML-Dokument so angegeben haben.</p>
<p>Für die Koordinaten benötigen wir noch eine Anbindung an den Shader. Diese wird erstellt mit</p>
<pre><code class="js">var positionAttributeLocation = gl.getAttribLocation(program, &quot;a_position&quot;);
</code></pre>
<p><code>a_position</code> ist ein Attribut, der später eine Koordinate enthält.</p>
<h2 id="Vorbereitungen-zum-Rendern"><a href="#Vorbereitungen-zum-Rendern" class="headerlink" title="Vorbereitungen zum Rendern"></a>Vorbereitungen zum Rendern</h2><p>Die nachfolgenden Schritte werden stets pro Frame vorgenommen.</p>
<h3 id="Kontext-an-Canvas-Grose-anpassen"><a href="#Kontext-an-Canvas-Grose-anpassen" class="headerlink" title="Kontext an Canvas-Größe anpassen"></a>Kontext an Canvas-Größe anpassen</h3><p>Damit WebGL jeweils mit dem Browser zusammen skaliert, muss der Viewport gesetzt werden:</p>
<pre><code class="js">gl.canvas.width = gl.canvas.clientWidth;
gl.canvas.height = gl.canvas.clientHeight;

gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
</code></pre>
<h3 id="Hintergrundfarbe-setzen"><a href="#Hintergrundfarbe-setzen" class="headerlink" title="Hintergrundfarbe setzen"></a>Hintergrundfarbe setzen</h3><p>Dazu wird zuerst die Farbe gesetzt und anschließend der Bildspeicher mit dieser Farbe gefüllt:</p>
<pre><code class="js">gl.clearColor(0.2, 0.2, 0.2, 1.0);
gl.clear(gl.COLOR_BUFFER_BIT);
</code></pre>
<p>Die erste Funktion setzt die Farbe und die zweite Funktion führt den Füllbefehl aus.</p>
<h3 id="Shader-aktivieren"><a href="#Shader-aktivieren" class="headerlink" title="Shader aktivieren"></a>Shader aktivieren</h3><p>Jetzt muss das zuvor erstellte Shader-Programm aktiviert werden und das Positionsattribut angebunden werden:</p>
<pre><code class="js">gl.useProgram(program);
gl.enableVertexAttribArray(positionAttributeLocation);
</code></pre>
<h3 id="Koordinaten-Puffer-aktivieren"><a href="#Koordinaten-Puffer-aktivieren" class="headerlink" title="Koordinaten-Puffer aktivieren"></a>Koordinaten-Puffer aktivieren</h3><p>Der zuvor erstellte Puffer für die Koordniaten muss jetzt wieder aktiviert werden:</p>
<pre><code class="js">gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
</code></pre>
<p>Der erste Parameter der zweiten Funktion enthält die Anbindung an das Attribut im Vertex-Shader, der zweite Parameter die Anzahl der Dimensionen (hier 2), der dritte Parameter den Variablentyp der Vertizen. Die anderen Parameter ignorieren wir vorerst.</p>
<h3 id="Zeichenbefehl-ubergeben"><a href="#Zeichenbefehl-ubergeben" class="headerlink" title="Zeichenbefehl übergeben"></a>Zeichenbefehl übergeben</h3><p>Jetzt kommt der eigentlich wichtigste Moment, das Zeichnen des Dreiecks:</p>
<pre><code class="js">gl.drawArrays(gl.TRIANGLES, 0, 3);
</code></pre>
<p>Der erste Parameter gibt an, auf welche Art er die zuvor angebundenen Koordinaten zeichen soll, der zweite Parameter den Offset im Array und der letzte Parameter die Anzahl der Koordinaten.</p>
<p>Das waren die Schritte, die zum Zeichnen eines Dreiecks nötig waren. Im nächsten Tutorial gehen wir näher auf die Shader ein, deren Verständnis wichtig ist für die darauffolgenden Tutorials.</p>

        </div>
    </div>
</div>

        <script src="https://code.jquery.com/jquery-3.1.1.min.js"></script>
        <script src="/webgl_tutorial/semantic.min.js"></script>
        <script src="/webgl_tutorial/helpers.js"></script>
        <script src="/webgl_tutorial/script.js"></script>
    </body>
</html>
